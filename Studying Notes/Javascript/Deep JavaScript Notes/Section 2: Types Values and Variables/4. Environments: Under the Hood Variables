Environment: Data Structure for Managing Variables
    Environment - The data structure used to manage Variables
        A dictionary whose keys are variable names and values are the value of the variables
        A scope has an associated environment
    Environments must support
        Recursion
        Nested Scopes
        Closures


Recursion via Environments
    ex_ To Consider|
        function f(x) {
            // Pause 3
            return x * 2;
        }
        function g(y) {
            // Pause 2
            const tmp = y + 1;
            return f(tmp);
        }
        // Pause 1s
        assert.equal(g(3), 8);

    For each function call you need a fresh storage space for the variables of the called function.
        This is managed via a stack of "execution contexts" aka environments
    Environments are stored on the heap
        heap - variable memory storage for variables/objects/functions/ and size is known at run time
        This is important since they are typically extant after leaving the scope of execution
            can''t be managed via a stack
    
    Executing the Code
        Start 0 
            Environment Contains:
                f - value of function f
                g - value of function g

        Pause 1 
            Before executing g() 
            Points the Stack to the Top Level Environment
            Environment Contains:
                y - value of 3
                tmp - value of 4

        Pause 2
            while executing g()
            Points the Stack to the environment for g()
            Environment Contains:
                x - value of 4

        Pause 3 
            while executing f()
            Points the Stack to the environment for f()
                  

        Every time there is a return, one execution is removed from the stack


Nested Scopes via Environments
    ex_|
        function f(x) {
            function square() {
                const result = x * x;
                // Pause 3
                return result;
            }
            // Pause 2
            reutrn square();
        }
        // Pause 1
        assert.equal(f(6), 36);

        There are three nested scopes
            Top Level Scope
            The Scope of f()
            The Scope of Square()

        Observations
            The scopes are connected
            The inner scope inherits all variables of the outer
                less the shadowed variables
            The mechanism of nesting scopes is independent of recursion
                Nesting scopes shows the relation between environments and their sub-environments
                Recursion is best managed by independent environments in the stack
    
    Code Execution Notes

        Start 0
            Loads:
                f()

            Execution Contexts:
                0 - f()

        Pause 1
            Loads: 
                x = 6
                square()

            Execution Contexts:
                0 - The Scope of f()
                1 - g()
                
        Pause 2
            Loads:
                result = 36

            Execution Contexts:
                0 - none
                1 - The Scope of g()
                2 - result 


Closures and Environments
    ex_|
        function add(x) {
            return (y) => {
                // Pause 3: plus2(5)
                reurn x + y;
            }; // Pause 1: add (2)
        }

        const plus2 = add(2);
        // Pause 2
        assert.equal(plus2(5), 7)
    
    Note, converting a function with two parameters into two nested functions is called curring
        add() is a curried function

    Executing the Code
        Start 0
            Loads:
                add()
                plus2(2)

            Execution Contexts:
                0 - add(2)  - for plus2(2)
        Pause 1
            Loads:
                x = 2

            Execution Contexts:
                0 - the scope of add()
                1 - the scope of add(2)
            
            Context:
                The function returned by plus() already exists under add(2)
                    it points to birth environment via add''s scope
        Pause 2
            Loads:
                add()
                plus2() - initialized and points to add scope
                
            
            Execution Contexts:
                0 - add()

            Context:
                x = 2 kept alive by plus2 pointing to scope created in add(2) 

        Pause 3
            Loads:
                y = 5
            
            Execution Context:
                0 - The scope of add(2)
                1 - the scope of y = 5
                