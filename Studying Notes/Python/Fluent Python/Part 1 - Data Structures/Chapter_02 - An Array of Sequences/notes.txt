Before Python, Guido van Rossum contributed to a beginner's programming language called ABC.
    This is where many "pythonic" ideas originated, like:
        Generic Operations on Different Sequence Types
        Built-in Tuple and Mapping Types
        Structure by Indentation
        Strong Typing Without Variable Declarations
        etc...

This chapter focuses on a small subjection of sequences that is built on in later chapters. 


Overview of Sequence Types

    Container - can hold items of different types, including containers.
        Hold references to the object it contains.

    Flat - can hold items of one simple type, ex: str, bytes, etc.
        Stores contents in their own memory space, not distinct objects.

    Note: Python objects in memory have a metadata header.
        Why is this important? Example for a 64-bit Python install:

            var_a: float = value
            # Float Header:
                # ob_refcnt - reference count 
                # ob_type   - pointer to the object's type
                # ob_fval   - a C double holding the float's value
                # Each field takes 8 bytes
            array_of_floats = [var_1, var_2, ..., var_n]
            # Saves one header, and a set of raw values
            tuple_of_floats = (var_1, var_2, ..., var_n)
            # Saves one header per value.

    Can also group sequence types by mutability.

        Mutable - Create Sequences
            __setitem__
            __delitem__
            insert
            append
            reverse
            extend
            pop
            remove
            __iadd__
        
        Sequence - Create Collections or Reversible
            __getitem__
            __contains__
            __iter__
            __reversed__
            index
            count
        
        Collection
            __contains__
            __len__
            __iter__
        
        Reversible
            __reversed__


List Comprehensions and Generator Expressions

    List Comprehension and Generator Expressions are quick ways to build sequences.

    List Comprehensions and Readability

        List Comprehensions should be used only when their readability is clearer than a for loop.
        ex:
            symbols = '!@#$%^'
            codes = []
            for symbol in symbols:
                codes.append(ord(symbol))
            
            Verses

            symbols = '!@#$%^'
            codes = [ord(symbol) for symbol in symbols]

        List Comprehensions shouldn't be longer than a line.

    Local Scope within Comprehensions and Generator Expressions

        Both have a local scope, but if variables are assigned with the walrus operator ' := '
            they will remain accessible after the Comprehension or Expression is returned.
            See 'examples.ipynb'

    Listcomps Versus map and filter

        Listcomps do everything that map and filter do but with less effort than lambda.
        Listcomps in this example are also faster than map and filter.
        See 'examples.ipynb'

    Cartesian Products

        Listcomps can build lists of two or more iterables.
        Cartesian Products are tuples made from items from every input iterable.
            The length of the list is equal to the product of the input lists.
        ex:
            The Cartesian Product of the sets, [Ace, King, Queen], [Spades, Clubs, Hearts, Diamonds]: 
            [(Ace, Spade), (Ace, Club), ..., (Queen, Diamonds)] - Length of 3*4 = 12.
        
        See 'examples.ipynb'

    Generator Expressions

        Genexp - shorthand for Generator Expression

        Genexps save memory by yielding items one at a time using the iterator protocol,
            instead of building the whole list just to feed data into another constructor one
                at a time.

        Genexps use the same syntax as Listcomps, but are enclosed in parenthesis.
            See 'examples.ipynb'


Tuples as Records Versus Tuples as Immutable Lists

    As Records

        Each item in the tuple holds data for one field, and the item's position gives it meaning.
        If a tuple is used as a collection of fields, order is explicitly important.
            See 'examples.ipynb'


    As Immutable Lists
        
        Used for:
            Clarity - a tuples length will never change.
            Performance - uses less memory than a list of the same length, and allows Python to optimize.
        
        References in a tuple cannot be deleted or replaced.
            If the reference itself is mutable, like a list inside of a tuple, if that changes
                so does the tuple. 
            See 'examples.ipynb'

        Are tuples more efficient than lists in Python?

            1. Evaluation:
                a tuple literal, the Python compiler generates bytecode for a tuple constant in one operation.
                a list literal, the generated bytecode pushes each element as a separate
                     constant to the data stack, then builds the list.
            2. Referencing:
                a tuple: t, tuple(t) returns a reference to the same t. There's no need to copy.
                a list: l, list(l) 's constructor must create a new copy of l.
            
            3. Memory Space:
                a tuple instance is allocated the exact memory space needed.
                a list instance is allocated more space to amortize the cost of future appends.

            4.  Pointer Referencing:
                tuple references to items are stored in an array within the tuple struct 
                list references to items are stored in a pointer array because
                    items could be stored elsewhere if the list grows large enough.
                    This extra indirection makes the CPU cache less effective.
            
    Shared Methods Between tuples and lists:
        s.__add__(s2)               - s + s2 - Concatenation
        s.__contains__(e)           - is e in s
        s.count(e)                  - Counts occurrences of e in s
        s.__getitem__(p)            - s[p] - gets item in s at index position p
        s.index(e)                  - Finds the position of element e in s
        s.__iter__()                - Gets the iterator
        s.__len__()                 - len(s) - The number of elements
        s.__mul__(n)                - s * n - Repeated concatenation
        s.__rmul__(n)               - n * s - Reversed concatenation

    Tuple Only Methods:
        s.__getnewargs__()          - Support for optimized serialization with pickle

    List Only Methods:
        s.__iadd__(s2)              - s += s2 - In-place concatenation
        s.append(e)                 - Append on element after the last element in s
        s.clear()                   - Delete all items in s
        s.copy()                    - Shallow copy of the list
        s.__delitem__(p)            - Remove items at index position p in s
        s.extend(it)                - Append items from iterable 'it' after the last element in s
        s.insert(p, e)              - Insert element e before the item at index position p
        s.__imul__(n)               - s *= n - In-place repeated concatenation
        s.pop([p])                  - Remove and return the last item, or the item at the optional index position p
        s.remove(e)                 - Remove the first occurrence of element e in s
        s.reverse()                 - Reverse the order of the items in place in s
        s.__reversed__()            - Get iterator to scan items from last to first in s
        s.__setitem__(p, e)         - s[p] = e - Put element e in index position p, overwriting the current value, in s
        s.sort([key], [reverse])    - Sort items in place in s, with optional kwargs key and reverse


Unpacking Sequences and Iterables

    Unpacking avoids error-prone use of indexes to extract elements from sequences.
    Unpacking works with any iterable object as the data source.
        This also works for iterators that don't support index notation []
    
    One Requirement - Each iterable yields exactly one item per variable receiving the index.
        The only excepting is using * .

    See 'examples.ipynb'



 Sequenced Pattern Matching

    For some robot class. THis method accepts commands sent as a sequence of words
        and numbers. After splitting into parts and parsing numbers, you have a message
            like ['BEEPER', 440, 3]
        Here's an example method to handle these commands:

        def handle_command(self, message):
            match message:
                case ['BEEPER', frequency, times]:
                    self.beep(times, frequency)
                case ['NECK', angle]:
                    self.rotate_neck(angle)
                case['LED', ident, intensity]:
                    self.leds[ident].set_brightness(ident, intensity)
                case['LED', ident, red, green, blue]:
                    self.leds[ident].set_color(ident,red,green,blue)
                case _:
                    raise InvalidCommand(message)

    match/case statements look like switch/case statements from C, but it improves on 
        switch/case by destructuring the imported data.

    See 'examples.ipynb'

    A sequence pattern matches the subject if the following apply:
        1. The subject is a sequence
        2. The subject and the pattern have the same number of items
        3. Each corresponding item matches, included nested items. 

    Sequence patterns can be any combination of tuples, lists, or nested tuples/lists with nested tuples/lists.
    
    Sequence pattern matches use parenthesis and square brackets interchangeably,
        avoid repeating brackets/parenthesis if possible. 

    Note: Instances of str, bytes, bytearray are handled as one value by match.
        ex: int 987 is treated as one value, not a list of three numbers.

    Patterns don't destructure iterables that aren't sequences.

    The '_' is the only variable that can appear more than once in a pattern.

    You can alias/keyword any part of a pattern with 'as'.
        ex: case [name, _, _, (lat, lon) as coord]
            # you can now reference '(lat, lon)' with the name coord.

    We can make patterns more specific with type casting.
        ex: case [str(name), _, _, (float(lat), float(lon))]: 
                ...
        
        Pattern Matching treats these 'str, float' not as constructors, but type checks.
    
    Matching against the start and end of a sequence with globs.
        ex: case [str(name), *_, (float(lat), float(lon))]:
                ...

        Note: Let's say we used *extra instead of _*, this would bind all items to a list
            under the name 'extra'.

    The optional guard clause in the above examples:
        match record:
            case [name, _, _, (lat, lon)] if long <= 0:
                print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
        
        This blocks the print statement only if the pattern matches 'truthly'.
    

Pattern Matching in an Interpreter

    lis.py is an interpreter for a subset of the 'Scheme' dialect used in Lisp.
        Peter Norvig did this in a succinct 132 lines o f code.
    
        We can compare the if/elif unpacking with match/case within this code.


    from lis.py
        parse('(gcd 18 45)')
        #returns ['gcd', 18, 45]
        parse('''
            (define double
                (lambda (n)
                    (* n 2)))
        ''')
        #returns ['define', 'double', ['lambda', ['n'], ['*', 'n', 2]]]

    evaluate from lis.py

        def evaluate(exp: Expression, env: Environment) -> Any:
            "Evaluate an expression in an environment."
            if isinstance(exp, Symbol):
                return env[exp]
            #   ... lines omitted
            elif exp[0] == 'quote':
                (_, x) = exp
                return x
            elif exp[0] == 'if':
                (_, test, consequence, alternative) = exp
                if evaluate(test, env):
                    return evaluate(consequence, env)
                else:
                    return evaluate(alternative, env)
            elif exp[0] == 'lambda':
                (_, parms, *body) = exp
                return Procedure(parms, body, env)
            elif exp[0] == 'define':
                (_, name, value_exp) = exp
                env[name] = evaluate(value_exp, env)
            # ... more lines omitted 

        Note: Each elif statement checks the first list item, unpacks the list, and ignores the first item.

    Comparing this with pattern matching in Python 3.10 and above:

        def evaluate(exp: Expression, env: Environment) -> Any:
            "Evaluate an expression in an environment."
            match exp:
            #   ... lines omitted
            case ['quote', x]:
                return x
            case ['if', test, consequence, alternative]:
                if evaluate(test, env):
                    return evaluate(consequence, env)
                else:
                    return evaluate(alternative, env)
            case ['lambda', [*parms], *body] if body:
                return Procedure(parms, body, env)
            case ['define', Symbol() as name, value_exp]:
                env[name] = evaluate(value_exp, env)
            #   ... more lines omitted

        We are able to use much more detailed pattern matching, de-clutter the code, and increase readability.


Alternative Pattern Matching

    Syntax of a lambda Scheme
        (lambda (params...) body1 body2 ...)

    Simple Pattern
        case ['lambda', parms, *body] if body:

        This matches ANY value in the parms position, including the first 'x' in this invalid list:
            ['lambda', 'x', ['*', 'x', 2]]
        The nested list after the lambda holds the name of the formal parameters.
            It MUST be a list, even if it is a list of len() = 1, or empty.

    In a sequence pattern, the '*' can only appear once per sequence. It can be nested to avoid this limitation.
        case ['lambda', [*parms], *body] if body:
            return Procedure(parms, body, env)

    Shortcut Syntax for Function Definition

        (define (name parm ...) body1 body2 ...)
    
        case ['define', [Symbol() as name, *parms], *body] if body:
            env[name = Procedure(parms, body, env)]

        Pattern matching is an example of declarative programming. The code describes what you want to match, not how.
    
    Scheme Syntactic Forms and Case Patterns to Handle Them:

        (quot exp)                                  ['quote', exp]
        (if test conseq alt)                        ['if', test, conseq, alt]
        (lambda (parms ...) body1 body2 ...)        ['lambda', [*parms], *body] if body
        (define name exp)                           ['define', Symbol() as name, exp]
        (define (name parms ...) body1 body2 ...)   ['define', [Symbol() as name, *parms], *body] if body


Slicing

    Why Slices and Ranges exclude the last item? 
        Zero-base indexing.

    Index Slicing
        var_name[<index->index+1>]
        var_name[<start_index>:<stop_index>]
        var_name[<start:stop:step_per_index_returned]
        var_name[::step_per_index_returned] # returns all indices in the set at the step int.
    
    Slicing can also return multiple slicing operations if you separate slices with commas.
    ex:
        a[start_1:end_1:stop_1, start_2:stop_2:end_2]
    
        This is used especially by NumPy for 2 dimensional array slicing for slicing the intersect join of columns and row slices.
    
    Using '. . .' can be used to create something functionally similar to f(x_1, ..., x_n) in slicing.
        This mimics something like this in code. var_name[x_1, :, :, :, :] 


    See 'examples.ipynb'

Using * and + with Sequences

    + and * always create new objects, and never change their operands.

    Automatic the creation of nested tuples with * can result in duplicate references to the same item.

    See 'examples.ipynb'

    +=
        += uses the method __iadd__ - in place addition.
        If __iadd__ is implemented:
            a += b is changed in place - i.e. a.extend(b)
        If __iadd__ is not implemented, it calls __add__ as a fallback.
            a += b -> a = a + b -> creates a new object equal to a + b, then binds the result to a.

        For mutable sequences, there's a good chance __iadd__ is implemented, for immutable sequences, it's unknown which method is used.  

        ex. 
        t = (1,2, [30,40])
        t[2] += [50,60]
        # t becomes (1,2, [30,40,50,60]) AND produces a TypeError.

            This fails because the nested list succeeds __iadd__, but fails when updating the tuple. 
        
    Best Practices
        
        Avoid putting mutable items in tuples.
        Augmented assignment is not an atomic operation.
        Inspecting Python bytecode can be extremely useful.

list.sort Verses the sorted Built-In

    list.sort sorts a list in-place, then returns nothing.
    sorted creates a new sorted list, and returns it.

    Both methods take the optional keywords:

        reverse - If true, items are returned in descending order.
        key - one-argument function that is applied to each item to produce it's sorting key.

When a List Is Not the Answer

    Note: If your code frequently checks item existence in a list, using a set can be faster for membership checking large data sets. 

    Arrays

        When a list only contains numbers.
        Arrays contain list operations plus extra methods for faster loading / saving like .frombytes, .tofile. 
        ex. It takes about 0.1 seconds to load 10 million double-precision floats from a binary file created with array.tofile.

        Additional Methods and Attributes in arrays not in lists:

            s.byteswap()     - Swap bytes of all items in array for endian-ness conversion.
            s.__copy__()     - Support for s.copy().
            s.__deepcopy__() - Optimized support for copy.deepcopy().
            s.frombytes(b)   - Append items from byte sequence interpreted as packed machine values.
            s.fromfile(f,n)  - Append n items from binary file f interpreted as packed machine values.
            s.fromlist(l)    - Append items from list; if one causes TypeError, none are appended.
            s.itemize        - Length in bytes of each array item.
            s.tobytes()      - Return items as packed machine values in a bytes object.
            s.tofile(f)      - Save items as packed machine values to binary file f.
            s.tolist()       - Return items as numeric objects in a list.
            s.typecode       - One-character string identifying the C type of the items. 


        Methods and Attributes in lists but not arrays:

            s.clear()
            s.copy()
            s.__reversed__()
            s.sort([key], [reverse])
        
        Note: As of Python 3.10, array doesn't have in-place sort, so use the following:
            a = array.array(a.typecode, sorted(a)) 
            This keeps an array sorted while adding items to itself.

    Memory Views

        A memoryview is a generalized NumPy array structure in base Python. It's a shared-memory sequence
            type that lets you slice arrays without copying bytes.
            memoryview.cast allows you to change the way multiple bytes are read / written as units without moving bytes around.
            memoryview.cast returns a new memoryview object, always sharing the same memory.

    NumPy

        A library that implements multi-dimensional, homogeneous arrays and matrix types 
            that hold numbers and records with efficient element-wise operations.
            
        SciPy is a library written over NumPy that offers algorithms from linear algebra, numerical calculus, and statistics.
            It's fast, reliable, and is built of C and Fortran for an interactive prompt, high-level api, 
                and industrial strength --- optimized number crunching. 

        Pandas is also built on top of Numpy.

    Deques and Other Queues

        Deque - Double Ended Queue
        Deque allows the removal of the 0-index item without the cost of shifting the entire list in memory.

        Additional Methods and Attributes in deques and not in lists:

            s.appendleft(e) - Append one element to the left (before first).
            s.__copy__() - Support for copy.copy().
            s.extendleft(i) - Append items from iterable i to the left.
            s.popleft() - Remove and return the first item.
            s.rotate(n) - Move n items from one end to the other (like shifting the queue).

        Methods and Attributes in lists but not deques:

            s.__add__(s2)
            s.__contains__(e)
            s.copy()
            s.index(e)
            s.insert(p, e)
            s.__mul__(n)
            s.__imul__(n)
            s.__rmul__(n)
            s.sort([key], [reverse])

        Other deque like queues in Python.
            queue - Synchronized (thread-safe) classes SimpleQueue, Queue, LifoQueue, PriorityQueue.
                Safe communication between threads, and all except SimpleQueue can be bounded by
                    providing max size argument greater than 0 to the constructor.
                They don't discard items like deque, i.e. they wait until some other thread makes room
                    by taking an item from the queue.
            multiprocessing - Implements it's own un-bounded SimpleQueue and bounded Queue---
                similar to Queue, but for inter-process communications.
                Includes a specialized multiprocessing.JoinableQueue for task management.
            asyncio - Provides Queue, LifoQueue, PriorityQueue, and JoinableQueue with API
                inspired by the classes in queue and multiprocessing modules, but adapted for
                managing tasks in asynchronous programming.  
            heapq
                Provides functions like heappush and heappop for mutable sequences.

Summary

    Tuples are used as records with unnamed fields, and immutable lists.